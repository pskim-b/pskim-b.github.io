<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on PS Developer Tech study</title>
    <link>/categories/architecture/</link>
    <description>Recent content in Architecture on PS Developer Tech study</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 09 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Design] 데이터 모델과 쿼리 </title>
      <link>/posts/book/data_intensive/20220109_02_data_modeling_and_query/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/book/data_intensive/20220109_02_data_modeling_and_query/</guid>
      <description>지극히 주관적인 요약 1. 데이터 모델 중요성 데이터 모델은 소프트웨어 개발에서 제일 중요한 부분 중 하나이다. 왜냐하면 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각하는지에 대해서도 지대한 영향을 미치기 때문이다.
데이터 모델은 여러 계층을 이루며 구성되는데 각 계층의 핵심적인 고민거리는 다음 하위 계층(down stream)을 위해 데이터를 어떻게 전달해야 하는지이다. 이는 단순히 application과 persistence 사이 뿐만이 아니라 application 내에서 또는 application 간에도 고민이 되어야 한다.
각 계층은 명확한 데이터 모델을 제공해 하위 계층에게 복잡성을 숨긴다.</description>
    </item>
    
    <item>
      <title>[Design] 전략 패턴, Strategy Pattern</title>
      <link>/posts/architecture/designpattern/202112_dp_strategy_pattern/</link>
      <pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/architecture/designpattern/202112_dp_strategy_pattern/</guid>
      <description>개요 Strategy pattern은 일련의 알고리즘을 정의하고 각각을 분리된 객체(class)에 넣어 필요에 따라 알고리즘을 교체할 수 있도록 만든 디자인 패턴이다.
문제 상황 예시 네비게이션 앱을 만든다고 생각해보자. 주어진 지도 위에 최단 거리를 구하기 위한 알고리즘을 구현해야 한다. 이러한 알고리즘은 자차, 도보, 대중교통을 이용할 때 각각 구현되어야 하며 필요에 따라서 하나를 선택하여 사용해야 한다. 또한 각각은 효율적으로 개발 배포될 수 있도록 구현되어야 하며 각 알고리즘의 영향을 최소한으로 해야한다.
설계 방안 classDiagramContext o-- StrategyStrategy Strategy pattern을 사용해서 필요한 알고리즘을 각각의 클래스로 구현한다.</description>
    </item>
    
    <item>
      <title>[MSA] 마이크로서비스 Frontend 통합 방안</title>
      <link>/posts/architecture/msa/msa_20210813_front-integration/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/architecture/msa/msa_20210813_front-integration/</guid>
      <description>마이크로서비스를 Web Frontend와 통합하는 방법을 알아보려고 한다.
 1. Frontend 구현 아키텍쳐 1.1 모놀리틱 Frontend + 모놀리틱 Backend 전통적인 웹 개발 방법으로 시스템이 너무 작거나 간단한 경우 모듈화는 하는 것 자체가 많은 노력이 필요하기 때문에, 이 경우 불피요한 모듈화 작업을 수행하지 않음으로써 이에 들어가는 에포트를 줄일 수 있다.
1.2 모듈화된 모놀리틱 Frontend + 마이크로서비스 Backend 모놀리틱으로 배포되는 frontend도 모듈화되어서 개발될 수 있다. 이 경우 모듈 단위로 개발할 수 있지만 결국 배포는 전체 frontend 단위로 수행되기 때문에 microservice가 갖는 배포 관점의 장점을 가질 수 없다.</description>
    </item>
    
    <item>
      <title>[MSA] SCS, Self-Contained System</title>
      <link>/posts/architecture/msa/msa_20210810_self-contained-system-%EB%B3%B5%EC%82%AC%EB%B3%B8/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/architecture/msa/msa_20210810_self-contained-system-%EB%B3%B5%EC%82%AC%EB%B3%B8/</guid>
      <description>정의 self-contained system (SCS) 는 도메인에 대한 전체 로직 로직, 데이터 및 UI 를 모두 포함하기 때문에 self-contained system이라고 부른다. SCS는 서로 다른 macro architecture에 대한 의사결정을 내릴 수 있는데, 이는 독립된 매크로 아키텍쳐를 정의한 시스템이 된다. SCS는 자율적인 웹 어플리케이션으로 WebUI가 포함되어 있다.
하나의 SCS는 다른 SCS에 대한 HTML 링크가 있거나 다른 SCS의 UI에 통합될 수 있다. SCS 간에는 공통된 UI는 존재하지 않으며, UI는 하나 이상의 SCS로 구성된다.이는 SCS가 UI의 일부 부분을 생성하는 것을 의미한다.</description>
    </item>
    
    <item>
      <title>[SWA]  System Design Warmup - 2 (작성중)</title>
      <link>/posts/architecture/systems/202106_system_design_2/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/architecture/systems/202106_system_design_2/</guid>
      <description>🏛️
대규모 데이터를 처리하기 위한 시스템을 설계할 때에 고려해야할 사항들이 존재한다. 효율적이고 경제적인 시스템을 구축하기 위해서 이러한 개념을 잘 알고 있어야 한다. 이러한 핵심 구성 요소는 아래와 같다
  CAP Theorem
  PACELC Theorem
  SQL vs NoSQL
  Load Balancing
  Caching
  Data Partitioning
  Redundancy &amp;amp; Replication
  Indexing
  Proxies
  Long Polling vs WebSocket vs Server-Sent Event</description>
    </item>
    
    <item>
      <title>[SWA]  System Design Warmup - 1</title>
      <link>/posts/architecture/systems/202106_system_design_1/</link>
      <pubDate>Wed, 23 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/architecture/systems/202106_system_design_1/</guid>
      <description>🏛️
대규모 데이터를 처리하기 위한 시스템을 설계할 때에 고려해야할 사항들이 존재한다. 효율적이고 경제적인 시스템을 구축하기 위해서 이러한 개념을 잘 알고 있어야 한다. 이러한 핵심 구성 요소는 아래와 같다
  CAP Theorem
  PACELC Theorem
  SQL vs NoSQL
  Load Balancing
  Caching
  Data Partitioning
  Redundancy &amp;amp; Replication
  Indexing
  Proxies
  Long Polling vs WebSocket vs Server-Sent Event</description>
    </item>
    
    <item>
      <title>[Enterprise Big DataLake] 01. Datalake 소개 </title>
      <link>/posts/bigdata/datalake/20210321_ebdl_01_datalake01/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/bigdata/datalake/20210321_ebdl_01_datalake01/</guid>
      <description>💾
국내에도 1~2년부터 데이터 레이크(Datalake)를 도입해야 한다고 하는 이야기가 우후죽순과도 같이 자라났다. 기존에 하둡도 있었고 Isilon 같은 스토리지도 있었지만, 데이터 레이크 도입에 대한 이야기는 AWS S3가 범용 스토리지로 사용되면서 더욱 활발해 지지 않았나 생각된다. 하지만 실제로 데이터 레이크를 이야기에 대한 이야기를 나누어보면 모두 생각 하는바가 달랐다. 단순히 더 큰 규모의 DW를 이야기하는가 하면, 또 다른 종류의 빅데이터 저장소(하둡과도 같은)를 이야기하기도 했다.
업무적으로 데이터 레이크를 관리하기 위한 도구를 기획하고 개발하는 업무를 하고 있음에도 불구하고, 이해관계자들의 청사진과 요구사항이 모두 달라 중심을 잡고 목소리를 내기 힘들어지기 시작했을 무렵 IT도서의 바이블과도 같은 O&amp;rsquo;REILLY의 도서로 &amp;lsquo;The Enterprise Big Data Lake&amp;rsquo;가 이미 번역되어 나온 것을 알게되어 일단 구매 후 읽어보기로 했다.</description>
    </item>
    
  </channel>
</rss>

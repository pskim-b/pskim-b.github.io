<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on PS Tech study</title>
    <link>/categories/java/</link>
    <description>Recent content in Java on PS Tech study</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 05 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[JAVA] 스트림 API (Stream API)</title>
      <link>/posts/java/202110_java_streaming/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/java/202110_java_streaming/</guid>
      <description>과거에는 Java에서 Stream은 데이터를 전달받거나 저장하기 위해서 많이 사용하였다. 하지만 함수형 프로그래밍 기반으로 프로그램을 작성하면서 데이터 처리에서도 활발하게 스트림 형태를 사용하기 시작했다.
 스트림 API (Stream API) 개요 데이터를 스트림 기반으로 처리하는 경우 다음과 같은 장점이 있음
 다양한 형태의 묶음형 데이터(Container)를 표준화된 방식으로 처리 가능.\  Stream randomStream = Stream.generate(Math::random); Stream strStream = Stream.of(new String[]{&amp;#34;w&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;w&amp;#34;}); 묶음형 데이터(Container)들의 요소를 순회하며 처리 가능  // asis : for(String name: names){ System.out.println(name); } aList().</description>
    </item>
    
    <item>
      <title>[JAVA] 함수형 프로그래밍(Functional Programming)</title>
      <link>/posts/java/202110_java_functional_programming-%EB%B3%B5%EC%82%AC%EB%B3%B8/</link>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/java/202110_java_functional_programming-%EB%B3%B5%EC%82%AC%EB%B3%B8/</guid>
      <description>전통적인 명령형 프로그래밍(imperative programming)은 데이터를 어떻게(how) 처리할 것인지를 단계별로 정의하는 방식이다.
이 방식에서는 각 단계에서 데이터가 어떻게 처리되고 프로그램의 상태 또는 플래그를 계속해서 유지하게 된다.
이와 비교되는 선언적 프로그래밍(declarative programming)은 무엇을(what) 처리해야 하는지를 표현함으로써 알고리즘 구현으로 인한 이슈를 최소화하거나 제거한다.
어떻게(how)에 해당하는 구현 부분은 별도로 작성하여 사용하도록 한다.
 함수형 프로그래밍(Functional Programming) 개요  함수형 프로그래밍은 프로그래밍 패러다임으로 프로그램을 함수를 통해서 표현하는 방식이며, 함수를 통해서 선언적 프로그래밍을 구현한 것이다. 선언적 프로그래밍 방식을 통해 로직에 대해서 더 높은 수준의 추상화가 되어있다.</description>
    </item>
    
  </channel>
</rss>

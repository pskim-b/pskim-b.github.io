<!doctype html>
<html lang="en-us">
  <head>
    <title>[QnA-Hadoop] 01.Hadoop 은 어떻게 이중화 되는가? (NameNode Failover process)  // PSKim Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="PS Kim" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://pskim-b.github.io/css/main.min.76ef0cfb451f3c25445362cc7e20819b297ba10edb78fc2e99a50553a4ce62a1.css" />

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[QnA-Hadoop] 01.Hadoop 은 어떻게 이중화 되는가? (NameNode Failover process) "/>
<meta name="twitter:description" content="🐘 하아두우웁!!
 Hadoop 2.0 버전부터 별도의 HA 솔루션 없이 Hadoop 자체적으로 이중화를 수행할 수 있도록 변경되었다. 최신 Hadoop 3.3.0 에서는 Observer NameNode라는 읽기 전용 NameNode가 별도로 도입되었지만 이 글에서는 다루지 않겠다. 자세한 내용은 Apache Hadoop 3.3.0 – Consistent Reads from HDFS Observer NameNode 를 참고 하시도록!
HDFS에서는 일반적으로 2개의 분리된 노드에 NameNode를 구성한다. 구성된 NameNode는 운영중에 하나는 Active 그리고 또 다른 한 대는 Standby 로 동작한다. Active NameNode는 HDFS에 대한 모든 client 요청을 담당한다."/>

    <meta property="og:title" content="[QnA-Hadoop] 01.Hadoop 은 어떻게 이중화 되는가? (NameNode Failover process) " />
<meta property="og:description" content="🐘 하아두우웁!!
 Hadoop 2.0 버전부터 별도의 HA 솔루션 없이 Hadoop 자체적으로 이중화를 수행할 수 있도록 변경되었다. 최신 Hadoop 3.3.0 에서는 Observer NameNode라는 읽기 전용 NameNode가 별도로 도입되었지만 이 글에서는 다루지 않겠다. 자세한 내용은 Apache Hadoop 3.3.0 – Consistent Reads from HDFS Observer NameNode 를 참고 하시도록!
HDFS에서는 일반적으로 2개의 분리된 노드에 NameNode를 구성한다. 구성된 NameNode는 운영중에 하나는 Active 그리고 또 다른 한 대는 Standby 로 동작한다. Active NameNode는 HDFS에 대한 모든 client 요청을 담당한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pskim-b.github.io/posts/hadoop/qna_01_hadoopqna/" />
<meta property="article:published_time" content="2021-04-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-04-01T00:00:00+00:00" />

	
	
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-TEFH3VCWGN"></script>
	
	<meta name="google-site-verification" content="u0ltI-GL7Num3qJUw3i_trrBYxESJVJTjI-k4GPWimU" />
	<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'G-TEFH3VCWGN');
	</script>


  </head>
  <body>
    <header class="app-header">
      <a href="https://pskim-b.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="PS Kim" /></a>
      <h1>PSKim Blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>기술 학습 블로그</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/gohugoio" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">[QnA-Hadoop] 01.Hadoop 은 어떻게 이중화 되는가? (NameNode Failover process) </h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 1, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://pskim-b.github.io/tags/interview/">interview</a>
              <a class="tag" href="https://pskim-b.github.io/tags/hadoop/">hadoop</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>🐘 하아두우웁!!</p>
<hr>
<p>Hadoop 2.0 버전부터 별도의 HA 솔루션 없이 Hadoop 자체적으로 이중화를 수행할 수 있도록 변경되었다. 최신 Hadoop 3.3.0 에서는 Observer NameNode라는 읽기 전용 NameNode가 별도로 도입되었지만 이 글에서는 다루지 않겠다. 자세한 내용은 <a href="https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/ObserverNameNode.html">Apache Hadoop 3.3.0 – Consistent Reads from HDFS Observer NameNode</a> 를 참고 하시도록!</p>
<p>HDFS에서는 일반적으로 2개의 분리된 노드에 NameNode를 구성한다. 구성된 NameNode는 운영중에 하나는 Active 그리고 또 다른 한 대는 Standby 로 동작한다. Active NameNode는 HDFS에 대한 모든 client 요청을 담당한다. 반면에 Standby Namenode는 빠르게 failover를 수행할 수 있도록 NameNode의 최신 상태 정보(fsimage) 를 가지고 있게된다. Standby NameNode는 Active NameNode와 상태정보를 최신으로 동기화 하기 위해서 두 대의 NameNode 모두 JournalNode 라고 불리는 별도의 데몬 프로세스와 통신한다.</p>
<p>Active NameNode에 의해서 namespace(HDFS 내의 논리적 영역)에 수정사항이 발생한다면 변경사항(edits)을 과반수 이상의 Journal Node에게 전달하게 된다. 그리고 Standby NameNode는 JournalNode로부터 이러한 edit 로그를 가져오게된다. Standby NameNode는 가져온 변경사항을 자신이 기존에 가지고 있는 namespace 정보에 반영한다. 만약 failover 상황이 발생하는 경우 Standby NameNode는 Active 상태로 변경되기 이전에 Journal Node로 부터 모든 변경사항(edits)을 읽어 완전히 namespace 가 최신상태일 수 있도록 한다.</p>
<p>빠른 failover를 위해 Standby NameNode가 DataNode에 위치하고 있는 block의 위치와 상관 없이 최신의 정보를 가지고 있어야 한다. 이를 위해 DataNode는 Active NameNode 뿐만 아니라 Standby NameNode에게도 주기적인 heart beat을 통해 block의 정보를 전달하게된다.</p>
<p>두 대의 NameNode를 통해 HA를 구성하고 정상적으로 동작하기 위해서는 반드시 1대의 Active NameNode만 존재할 수 있도록 보장해야 한다. 너무 빠르게 namespace의 상태 정보가 Active NameNode에서 Standby NameNode로 전달이 되게 되면 중간에 데이터 유실이 발생하거나 올바르지 않은 결과를 얻을 수 있다. 예를들어 네트워크 이슈로 두개의 rack에 분리되어 위치하고 있는 NameNode가 통신이 되지 않는 경우, 각 rack 의 DataNode는 자신의 rack의 NameNode를 Active 상태로 인식하고 데이터를 전달하게 된다. 이 경우 두 NameNode는 서로 다른 데이터를 전달 받게 된다. 이러한 현상을 <strong>Split-Brain</strong> 이라고 한다.  이러한 현상을 피하기 위해서 Journal Node는 한번에 하나의 NameNode만 Write 작업을 할 수 있도록 강제한다.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
